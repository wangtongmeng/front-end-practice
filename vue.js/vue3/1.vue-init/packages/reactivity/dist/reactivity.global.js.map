{"version":3,"file":"reactivity.global.js","sources":["../../shared/src/index.ts","../src/effect.ts","../src/baseHandlers.ts","../src/reactive.ts","../src/ref.ts"],"sourcesContent":["export function isObject(val) {\r\n    return typeof val == 'object' && val !== null;\r\n}\r\n// ...\r\n\r\nexport function hasChanged(oldValue, newValue) {\r\n    return oldValue !== newValue\r\n}\r\n\r\nexport let isArray = Array.isArray;\r\n\r\nexport let extend = Object.assign;\r\n\r\n\r\nexport const isIntegerKey = (key) => {\r\n    return parseInt(key) + '' === key\r\n}\r\n\r\nexport const hasOwn = (target,key)=> Object.prototype.hasOwnProperty.call(target,key)","import { isArray, isIntegerKey } from \"@vue/shared\";\r\n\r\nexport function effect(fn, options: any = {}) {\r\n    const effect = createReactiveEffect(fn,options);\r\n    if(!options.lazy){\r\n        effect();\r\n    }\r\n    return effect; // 返回响应式的effect\r\n}   \r\nexport let activeEffect;\r\nconst effectStack = [];\r\nlet id = 0;\r\n\r\n// 当用户取值的时候需要将activeEffect 和 属性做关联\r\n// 当用户更改的时候 要通过属性找到effect重新执行\r\nfunction createReactiveEffect(fn,options){\r\n    const effect = function reactiveEffect(){ // 这就是effect中的effect\r\n        try{\r\n            effectStack.push(effect);\r\n            activeEffect = effect;\r\n            return fn(); // 会取值\r\n        }finally{\r\n            effectStack.pop();\r\n            activeEffect = effectStack[effectStack.length -1 ];\r\n        }\r\n    }\r\n    effect.id = id++; // 构建的是一个id\r\n    effect.__isEffect = true;\r\n    effect.options = options;\r\n    effect.deps = []; // effect用来收集依赖了那些属性\r\n    return effect;\r\n}\r\n// 一个属性对应多个effect， 一个effect还可以对应多个属性\r\n// target key = [effect,effect]\r\n\r\n// Map{\r\n//     {name:'zf',age:12}:{\r\n//         age:new Set(effect),\r\n//         name:new Set(effect),\r\n//     },\r\n// }\r\nconst targetMap = new WeakMap;\r\nexport function track(target,type,key){\r\n    if(activeEffect == undefined){\r\n        return; // 用户只是取了值，而且这个值不是在effect中使用的 ，什么都不用收集\r\n    }\r\n    let depsMap =  targetMap.get(target);\r\n    if(!depsMap) {\r\n        targetMap.set(target,(depsMap = new Map()))\r\n    }\r\n    let dep = depsMap.get(key);\r\n    if(!dep){\r\n        depsMap.set(key,( dep = new Set()))\r\n    }\r\n    if(!dep.has(activeEffect)){\r\n        dep.add(activeEffect)\r\n    }\r\n}\r\nexport function trigger(target,type,key,newValue,oldValue?){\r\n    // 去映射表里找到属性对应的 effect， 让她重新执行\r\n    const depsMap = targetMap.get(target);\r\n    if(!depsMap) return; // 只是改了属性，这个属性没有在effect中使用\r\n    const effectsSet=  new Set();\r\n    const add = (effectsAdd)=>{ // 如果同时有多个 依赖的effect是同一个 还用set做了一个过滤\r\n        if(effectsAdd){\r\n            effectsAdd.forEach(effect=>effectsSet.add(effect));\r\n        }\r\n    }\r\n    // 1.如果更改的数组长度 小于依赖收集的长度 要触发重新渲染\r\n    // 2.如果调用了push方法 或者其他新增数组的方法（必须能改变长度的方法）， 也要触发更新\r\n    if(key === 'length' && isArray(target)){ // 如果是数组，你改了length\r\n        depsMap.forEach((dep,key)=>{\r\n            if(key > newValue || key === 'length'){\r\n                add(dep); // 更改的数组长度 比收集到的属性的值小\r\n            }\r\n        })\r\n    }else{\r\n        add(depsMap.get(key));\r\n        switch(type){\r\n            case 'add':\r\n                if(isArray(target) && isIntegerKey(key)){\r\n                    add(depsMap.get('length')); // 增加属性 需要触发length的依赖收集\r\n                }\r\n        }\r\n    }\r\n    effectsSet.forEach((effect:any)=>effect());\r\n    // 23 继续\r\n}\r\n// [fn1] activeEffect = fn1   proxy.name\r\n// [fn1,fn2]  activeEffect = fn2   proxy.agre\r\n// [fn1] activeEffect = fn1 =  Proxy.address:\r\n// effect(()=>{ // fn1\r\n//     proxy.name\r\n//     effect(()=>{ // fn2\r\n//         proxy.agre\r\n//     })\r\n//     Proxy.address:\r\n// })","import { extend, hasChanged, isArray, isObject, hasOwn, isIntegerKey } from \"@vue/shared\";\r\nimport { reactive, readonly } from \"./reactive\";\r\nimport {activeEffect, track, trigger} from './effect'\r\nfunction createGetter(isReadonly = false, shallow = false) {\r\n    /**\r\n     * target 是原来的对象\r\n     * key 去取什么属性\r\n     * recevier 代理对象\r\n     */\r\n    return function get(target, key, receiver) {\r\n        // return target[key];\r\n        // Reflect 就是要后续慢慢替换掉Object对象，一般使用proxy 会配合Reflect\r\n        const res = Reflect.get(target, key, receiver); // Reflect.ownKey Reflect.defineProperty\r\n        if (!isReadonly) {\r\n           track(target,'get',key);\r\n        }\r\n        if (shallow) {\r\n            return res;\r\n        }\r\n        if (isObject(res)) { // 懒递归 当我们取值的时候才去做递归代理，如果不取默认值代理一层\r\n            return isReadonly ? readonly(res) : reactive(res);\r\n        }\r\n        return res;\r\n    }\r\n    // vue3 针对的是对象来进行劫持， 不用改写原来的对象,如果是嵌套，当取值的时候才会代理\r\n    // vue2 针对的是属性劫持，改写了原来对象，一上来就递归的\r\n    // vue3 可以对不存在的属性进行获取，也会走get方法, proxy支持数组\r\n}\r\nfunction createSetter(shallow = false) {\r\n    // 针对数组而言 如果调用push方法，就会产生2次触发 1.给数组新增了一项，同时也更改了长度 2.因为更改了长度再次触发set （第二次的触发是无意义的）\r\n    return function set(target, key, value, receiver) {\r\n        const oldValue = target[key]; // 获取老值\r\n        // target[key] = value; // 如果设置失败 没有返回值\r\n        // 有一个属性不能被修改 target[key] = value;  不会报错，但是通过Reflect.set 会返回false\r\n        // 设置属性，可能以前有，还有可能以前没有 （新增和修改）\r\n        // 如何判断数组是新增还是修改\r\n       \r\n        let hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);\r\n        const res = Reflect.set(target, key, value, receiver);\r\n        if(!hadKey){\r\n            trigger(target,'add',key,value);\r\n        }else if (hasChanged(oldValue, value)) {\r\n            trigger(target,'set',key,value,oldValue);\r\n        }\r\n     \r\n        return res\r\n    }\r\n}\r\nconst get = createGetter(); // 不是仅读的也不是浅的\r\nconst shallowGet = createGetter(false, true)\r\nconst readonlyGet = createGetter(true);\r\nconst shallowReadonlyGet = createGetter(true, true);\r\nconst set = createSetter();\r\nconst shallowSet = createSetter(true); // readonly没有set\r\n// new Proxy(target,{})\r\nexport const mutableHandler = { // reactive中的get和set\r\n    get,\r\n    set\r\n}\r\nexport const shallowReactiveHandlers = {\r\n    get: shallowGet,\r\n    set: shallowSet\r\n}\r\nlet readonlySet = {\r\n    set(target, key) {\r\n        console.warn(`cannot set ${JSON.stringify(target)} on  key ${key} falied`)\r\n    }\r\n}\r\nexport const readonlyHandlers = extend({\r\n    get: readonlyGet,\r\n}, readonlySet)\r\nexport const shallowReadonlyHanlders = extend({\r\n    get: shallowReadonlyGet\r\n}, readonlySet)\r\n\r\n// 取值 设置值 ","// 是否是浅的，默认是深度\r\n\r\nimport { isObject } from \"@vue/shared\";\r\nimport { mutableHandler, readonlyHandlers, shallowReactiveHandlers, shallowReadonlyHanlders } from \"./baseHandlers\";\r\n\r\n// 是否是仅读的 默认不是仅读的\r\n\r\nexport function reactive(target) {\r\n    return createReactiveObject(target, false, mutableHandler);\r\n}\r\nexport function shallowReactive(target) {\r\n    return createReactiveObject(target, false, shallowReactiveHandlers);\r\n}\r\nexport function readonly(target) {\r\n    return createReactiveObject(target, true, readonlyHandlers);\r\n}\r\nexport function shallowReadonly(target) {\r\n    return createReactiveObject(target, true, shallowReadonlyHanlders);\r\n}\r\n/**\r\n * \r\n * @param target 创建代理的目标\r\n * @param isReadonly 当前是不是仅读的\r\n * @param baseHandler 针对不同的方式创建不同的代理对象  \r\n */\r\n// weakMap(key只能是对象) map(key可以是其他类型)\r\nconst reactiveMap = new WeakMap(); // 目的是添加缓存\r\nconst readonlyMap = new WeakMap();\r\nfunction createReactiveObject(target, isReadonly, baseHandler) {\r\n    if(!isObject(target)){\r\n        return target;\r\n    }\r\n    const proxyMap = isReadonly? readonlyMap:reactiveMap\r\n    const existProxy = proxyMap.get(target);\r\n    if(existProxy){\r\n        return existProxy;// 如果已经代理过了，那就直接把上次的代理返回就可以的 \r\n    }\r\n    // 如果是对象 就做一个代理 new proxy\r\n    const proxy = new Proxy(target,baseHandler);\r\n    proxyMap.set(target,proxy);\r\n    return proxy;\r\n}\r\n\r\n// 数组，对象是如何劫持 effect 的实现 ref的实现。。。","import { hasChanged, isObject } from \"@vue/shared\";\r\nimport { track, trigger } from \"./effect\";\r\nimport { reactive } from \"./reactive\";\r\n\r\nexport function ref(value){ // 可以传入对象\r\n    // 把普通值变成一个引用类型, 让一个普通值也具备响应式的能力\r\n    return createRef(value)\r\n}\r\n\r\n\r\nexport function shallowRef(value){ \r\n    return createRef(value,true)\r\n}\r\n\r\n\r\n// ts 中实现类的话 私有属性必须要先声明才能使用\r\nconst  convert = (v) => isObject(v) ? reactive(v) : v;\r\nclass RefImpl { // 以前实现原理 确实是个对象，但是为了识别身份，用了类\r\n    public _value;\r\n    public __v_isRef = true // 表示他是一个ref\r\n    // public rawValue\r\n    constructor(public rawValue,public shallow){\r\n        this._value = shallow ? rawValue : convert(rawValue)\r\n        // this.rawValue = rawValue\r\n    }\r\n    get value(){\r\n        // 收集依赖\r\n        track(this,'get','value')\r\n        return this._value;\r\n    }\r\n    set value(newValue){\r\n        // 触发依赖\r\n        if(hasChanged(newValue,this.rawValue)){\r\n            this.rawValue = newValue; // 用于下次比对\r\n            this._value = this.shallow ? newValue : convert(newValue)\r\n\r\n            trigger(this,'set','value',newValue)\r\n        }\r\n    }\r\n}\r\nfunction createRef(value,shallow = false){\r\n    return new RefImpl(value,shallow); // 借助类的属性访问器 \r\n}\r\n\r\n// ref 其他方法实现 计算实习\r\n// effect 和 reactive 和 ref的关系 \r\n// computed 通过源码调试一遍\r\n// 把vue3的渲染原理，diff算法"],"names":[],"mappings":"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"}