{"version":3,"file":"reactivity.global.js","sources":["../../shared/src/index.ts","../src/effect.ts","../src/baseHandlers.ts","../src/reactive.ts","../src/ref.ts","../src/computed.ts"],"sourcesContent":["export function isObject(val) {\n    return typeof val == 'object' && val !== null;\n}\n// ...\n\nexport function hasChanged(oldValue, newValue) {\n    return oldValue !== newValue\n}\n\nexport let isArray = Array.isArray;\n\nexport let extend = Object.assign;\n\n\nexport const isIntegerKey = (key) => {\n    return parseInt(key) + '' === key\n}\n\nexport const hasOwn = (target,key)=> Object.prototype.hasOwnProperty.call(target,key)","import { isArray, isIntegerKey } from \"@vue/shared\";\n\nexport function effect(fn, options: any = {}) {\n    const effect = createReactiveEffect(fn,options);\n    if(!options.lazy){\n        effect();\n    }\n    return effect; // 返回响应式的effect\n}   \nexport let activeEffect;\nconst effectStack = [];\nlet id = 0;\n\n// 当用户取值的时候需要将activeEffect 和 属性做关联\n// 当用户更改的时候 要通过属性找到effect重新执行\nfunction createReactiveEffect(fn,options){\n    const effect = function reactiveEffect(){ // 这就是effect中的effect\n        try{\n            effectStack.push(effect);\n            activeEffect = effect;\n            return fn(); // 会取值\n        }finally{\n            effectStack.pop();\n            activeEffect = effectStack[effectStack.length -1 ];\n        }\n    }\n    effect.id = id++; // 构建的是一个id\n    effect.__isEffect = true;\n    effect.options = options;\n    effect.deps = []; // effect用来收集依赖了那些属性\n    return effect;\n}\n// 一个属性对应多个effect， 一个effect还可以对应多个属性\n// target key = [effect,effect]\n\n// Map{\n//     {name:'zf',age:12}:{\n//         age:new Set(effect),\n//         name:new Set(effect),\n//     },\n// }\nconst targetMap = new WeakMap;\nexport function track(target,type,key){\n    if(activeEffect == undefined){\n        return; // 用户只是取了值，而且这个值不是在effect中使用的 ，什么都不用收集\n    }\n    let depsMap =  targetMap.get(target);\n    if(!depsMap) {\n        targetMap.set(target,(depsMap = new Map()))\n    }\n    let dep = depsMap.get(key);\n    if(!dep){\n        depsMap.set(key,( dep = new Set()))\n    }\n    if(!dep.has(activeEffect)){\n        dep.add(activeEffect)\n    }\n}\nexport function trigger(target,type,key,newValue?,oldValue?){\n    // 去映射表里找到属性对应的 effect， 让她重新执行\n    const depsMap = targetMap.get(target);\n    if(!depsMap) return; // 只是改了属性，这个属性没有在effect中使用\n    const effectsSet=  new Set();\n    const add = (effectsAdd)=>{ // 如果同时有多个 依赖的effect是同一个 还用set做了一个过滤\n        if(effectsAdd){\n            effectsAdd.forEach(effect=>effectsSet.add(effect));\n        }\n    }\n    // 1.如果更改的数组长度 小于依赖收集的长度 要触发重新渲染\n    // 2.如果调用了push方法 或者其他新增数组的方法（必须能改变长度的方法）， 也要触发更新\n    if(key === 'length' && isArray(target)){ // 如果是数组，你改了length\n        depsMap.forEach((dep,key)=>{\n            if(key > newValue || key === 'length'){\n                add(dep); // 更改的数组长度 比收集到的属性的值小\n            }\n        })\n    }else{\n        add(depsMap.get(key));\n        switch(type){\n            case 'add':\n                if(isArray(target) && isIntegerKey(key)){\n                    add(depsMap.get('length')); // 增加属性 需要触发length的依赖收集\n                }\n        }\n    }\n    effectsSet.forEach((effect:any)=>{\n        // 数据变化原则上应该触发对应的effect让他重新执行,如果effect提供了scheduler那么就让这个scheduler执行，不让effect重新执行\n        if(effect.options.schedular){\n            effect.options.schedular(effect)\n        }else{\n            effect();\n        }\n    });\n    // 23 继续\n}\n// [fn1] activeEffect = fn1   proxy.name\n// [fn1,fn2]  activeEffect = fn2   proxy.agre\n// [fn1] activeEffect = fn1 =  Proxy.address:\n// effect(()=>{ // fn1\n//     proxy.name\n//     effect(()=>{ // fn2\n//         proxy.agre\n//     })\n//     Proxy.address:\n// })","import { extend, hasChanged, isArray, isObject, hasOwn, isIntegerKey } from \"@vue/shared\";\nimport { reactive, readonly } from \"./reactive\";\nimport {activeEffect, track, trigger} from './effect'\nfunction createGetter(isReadonly = false, shallow = false) {\n    /**\n     * target 是原来的对象\n     * key 去取什么属性\n     * recevier 代理对象\n     */\n    return function get(target, key, receiver) {\n        // return target[key];\n        // Reflect 就是要后续慢慢替换掉Object对象，一般使用proxy 会配合Reflect\n        const res = Reflect.get(target, key, receiver); // Reflect.ownKey Reflect.defineProperty\n        if (!isReadonly) {\n           track(target,'get',key);\n        }\n        if (shallow) {\n            return res;\n        }\n        if (isObject(res)) { // 懒递归 当我们取值的时候才去做递归代理，如果不取默认值代理一层\n            return isReadonly ? readonly(res) : reactive(res);\n        }\n        return res;\n    }\n    // vue3 针对的是对象来进行劫持， 不用改写原来的对象,如果是嵌套，当取值的时候才会代理\n    // vue2 针对的是属性劫持，改写了原来对象，一上来就递归的\n    // vue3 可以对不存在的属性进行获取，也会走get方法, proxy支持数组\n}\nfunction createSetter(shallow = false) {\n    // 针对数组而言 如果调用push方法，就会产生2次处罚 1.给数组新增了一项，同时也更改了长度 2.因为更改了长度再次触发set （第二次的触发是无意义的）\n    return function set(target, key, value, receiver) {\n        const oldValue = target[key]; // 获取老值\n        // target[key] = value; // 如果设置失败 没有返回值\n        // 有一个属性不能被修改 target[key] = value;  不会报错，但是通过Reflect.set 会返回false\n        // 设置属性，可能以前有，还有可能以前没有 （新增和修改）\n        // 如何判断数组是新增还是修改\n       \n        let hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);\n        const res = Reflect.set(target, key, value, receiver);\n        if(!hadKey){\n            trigger(target,'add',key,value);\n        }else if (hasChanged(oldValue, value)) {\n            trigger(target,'set',key,value,oldValue);\n        }\n     \n        return res\n    }\n}\nconst get = createGetter(); // 不是仅读的也不是浅的\nconst shallowGet = createGetter(false, true)\nconst readonlyGet = createGetter(true);\nconst shallowReadonlyGet = createGetter(true, true);\nconst set = createSetter();\nconst shallowSet = createSetter(true); // readonly没有set\n// new Proxy(target,{})\nexport const mutableHandler = { // reactive中的get和set\n    get,\n    set\n}\nexport const shallowReactiveHandlers = {\n    get: shallowGet,\n    set: shallowSet\n}\nlet readonlySet = {\n    set(target, key) {\n        console.warn(`cannot set ${JSON.stringify(target)} on  key ${key} falied`)\n    }\n}\nexport const readonlyHandlers = extend({\n    get: readonlyGet,\n}, readonlySet)\nexport const shallowReadonlyHanlders = extend({\n    get: shallowReadonlyGet\n}, readonlySet)\n\n// 取值 设置值 ","// 是否是浅的，默认是深度\n\nimport { isObject } from \"@vue/shared\";\nimport { mutableHandler, readonlyHandlers, shallowReactiveHandlers, shallowReadonlyHanlders } from \"./baseHandlers\";\n\n// 是否是仅读的 默认不是仅读的\n\nexport function reactive(target) {\n    return createReactiveObject(target, false, mutableHandler);\n}\nexport function shallowReactive(target) {\n    return createReactiveObject(target, false, shallowReactiveHandlers);\n}\nexport function readonly(target) {\n    return createReactiveObject(target, true, readonlyHandlers);\n}\nexport function shallowReadonly(target) {\n    return createReactiveObject(target, true, shallowReadonlyHanlders);\n}\n/**\n * \n * @param target 创建代理的目标\n * @param isReadonly 当前是不是仅读的\n * @param baseHandler 针对不同的方式创建不同的代理对象  \n */\n// weakMap(key只能是对象) map(key可以是其他类型)\nconst reactiveMap = new WeakMap(); // 目的是添加缓存\nconst readonlyMap = new WeakMap();\nfunction createReactiveObject(target, isReadonly, baseHandler) {\n    if(!isObject(target)){\n        return target;\n    }\n    const proxyMap = isReadonly? readonlyMap:reactiveMap\n    const existProxy = proxyMap.get(target);\n    if(existProxy){\n        return existProxy;// 如果已经代理过了，那就直接把上次的代理返回就可以的 \n    }\n    // 如果是对象 就做一个代理 new proxy\n    const proxy = new Proxy(target,baseHandler);\n    proxyMap.set(target,proxy);\n    return proxy;\n}\n\n// 数组，对象是如何劫持 effect 的实现 ref的实现。。。","import { hasChanged, isArray, isObject } from \"@vue/shared\";\nimport { track, trigger } from \"./effect\";\nimport { reactive } from \"./reactive\";\n\nexport function ref(value) { // 可以传入对象\n    // 把普通值变成一个引用类型, 让一个普通值也具备响应式的能力\n    return createRef(value)\n}\n\n\nexport function shallowRef(value) {\n    return createRef(value, true)\n}\n\n\n// ts 中实现类的话 私有属性必须要先声明才能使用\nconst convert = (v) => isObject(v) ? reactive(v) : v;\nclass RefImpl { // 以前实现原理 确实是个对象，但是为了识别身份，用了类\n    public _value;\n    public __v_isRef = true // 表示他是一个ref\n    // public rawValue\n    constructor(public rawValue, public shallow) {\n        this._value = shallow ? rawValue : convert(rawValue)\n        // this.rawValue = rawValue\n    }\n    get value() {\n        // 收集依赖\n        track(this, 'get', 'value')\n        return this._value;\n    }\n    set value(newValue) {\n        // 触发依赖\n        if (hasChanged(newValue, this.rawValue)) {\n            this.rawValue = newValue; // 用于下次比对\n            this._value = this.shallow ? newValue : convert(newValue)\n\n            trigger(this, 'set', 'value', newValue)\n        }\n    }\n}\nfunction createRef(value, shallow = false) {\n    return new RefImpl(value, shallow); // 借助类的属性访问器 \n}\n\nclass ObjectRefImpl {\n    public __v_isRef = true;\n    constructor(public target, public key) {\n    }\n    get value() {\n        return this.target[this.key];\n    }\n    set value(newValue) {\n        this.target[this.key] = newValue\n    }\n}\nexport function toRef(target, key) {\n    return new ObjectRefImpl(target, key)\n}\n\nexport function toRefs(target){\n    const res = isArray(target)? new Array(target.length) : {};\n    for(let key in target){\n        res[key] = toRef(target,key)\n    }\n    return res;\n}\n\n// ref 其他方法实现 计算实习\n// effect 和 reactive 和 ref的关系 \n// computed 通过源码调试一遍\n// 把vue3的渲染原理，diff算法","import { isObject } from \"@vue/shared\";\nimport { effect, track, trigger } from \"./effect\";\nclass ComputedRefImpl {\n    public effect;\n    public _value;\n    public _dirty = true\n    constructor(public getter, public setter) {\n        // 返还了 effect的执行权限\n        // 我们传入了scheduler后，下次数据更新，原则上应该让effect重新执行，下次更新会调用scheduler\n        this.effect = effect(getter, {\n            lazy: true, schedular: (effect) => {\n                // 自己来实现逻辑\n                if(!this._dirty){\n                    console.log('用户更改了依赖的属性')\n                    this._dirty = true;  \n                    trigger(this,'get','value');\n                }\n            }\n        })\n    }\n    // 如果用户不去计算属性中取值 就不会执行计算属性的effect\n    get value() {\n        if (this._dirty) {\n            this._value = this.effect();\n            this._dirty = false;\n        }\n        track(this,'get','value')\n        return this._value\n    }\n    set value(newValue) {\n        // 当用户给计算属性设置值的时候会触发 set方法，此时调用计算属性的setter\n        this.setter(newValue)\n    }\n}\nexport function computed(getterOrOptions) {\n    let getter;\n    let setter;\n\n    if (isObject(getterOrOptions)) {\n        getter = getterOrOptions.get;\n        setter = getterOrOptions.set;\n    } else {\n        getter = getterOrOptions;\n        setter = () => {\n            console.log(`computed not set`)\n        }\n    }\n    return new ComputedRefImpl(getter, setter)\n}"],"names":[],"mappings":"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"}